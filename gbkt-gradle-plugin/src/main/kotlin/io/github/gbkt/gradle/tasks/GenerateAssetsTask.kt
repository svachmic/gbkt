/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Copyright (c) 2026 Michal Svacha
 */
package io.github.gbkt.gradle.tasks

import javax.inject.Inject
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction

/**
 * Generates a type-safe Assets object from the assets directory.
 *
 * Scans the asset directory for sprite, tile, sound, music, and font files and generates a Kotlin
 * object with type-safe references.
 *
 * ## Generated Output
 *
 * ```kotlin
 * // Generated by gbkt-gradle-plugin - do not edit
 * package <configured-package>
 *
 * import io.github.gbkt.core.assets.*
 *
 * object Assets : AssetRegistry {
 *     object Sprites {
 *         val player = SpriteAsset("player.png")
 *         val enemy = SpriteAsset("sprites/enemy.png")
 *     }
 *
 *     object Sounds {
 *         val jump = SoundAsset("sounds/jump.wav")
 *     }
 *
 *     override val sprites = mapOf(
 *         "player" to Sprites.player,
 *         "enemy" to Sprites.enemy
 *     )
 *
 *     override val sounds = mapOf(
 *         "jump" to Sounds.jump
 *     )
 * }
 * ```
 *
 * ## Usage in build.gradle.kts
 *
 * ```kotlin
 * gbkt {
 *     generateAssets {
 *         enabled.set(true)
 *         packageName.set("com.example.mygame")
 *     }
 * }
 * ```
 */
@CacheableTask
abstract class GenerateAssetsTask @Inject constructor() : DefaultTask() {

    /** Input directory containing asset files. */
    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val assetDirectory: DirectoryProperty

    /** Output Kotlin file for the generated Assets object. */
    @get:OutputFile abstract val outputFile: RegularFileProperty

    /** Package name for the generated Assets class. */
    @get:Input abstract val packageName: Property<String>

    /** Name of the generated object (default: "Assets"). */
    @get:Input @get:Optional abstract val objectName: Property<String>

    init {
        description = "Generate type-safe Assets object from asset directory"
        group = "gbkt"

        // Defaults
        objectName.convention("Assets")
    }

    @TaskAction
    fun generate() {
        val assetDir = assetDirectory.get().asFile
        val outputKotlin = outputFile.get().asFile
        val pkg = packageName.get()
        val objName = objectName.get()

        if (!assetDir.exists()) {
            logger.lifecycle("Asset directory does not exist: ${assetDir.absolutePath}")
            logger.lifecycle("Generating empty Assets object")
            outputKotlin.parentFile.mkdirs()
            outputKotlin.writeText(generateEmptyAssets(pkg, objName))
            return
        }

        logger.lifecycle("Scanning assets in: ${assetDir.absolutePath}")

        // Collect assets by type
        val sprites = mutableListOf<AssetInfo>()
        val tiles = mutableListOf<AssetInfo>()
        val sounds = mutableListOf<AssetInfo>()
        val music = mutableListOf<AssetInfo>()
        val fonts = mutableListOf<AssetInfo>()

        assetDir
            .walkTopDown()
            .filter { it.isFile }
            .forEach { file ->
                val relativePath = file.relativeTo(assetDir).path.replace("\\", "/")
                val name = file.nameWithoutExtension.toKotlinIdentifier()

                when {
                    // Sprites/tiles - PNG and BMP images
                    file.extension.lowercase() in listOf("png", "bmp") -> {
                        // Check if it's in a specific subdirectory to determine type
                        when {
                            relativePath.startsWith("tiles/") ||
                                relativePath.startsWith("tilesets/") -> {
                                tiles.add(AssetInfo(name, relativePath))
                            }
                            relativePath.startsWith("fonts/") -> {
                                fonts.add(AssetInfo(name, relativePath))
                            }
                            else -> {
                                sprites.add(AssetInfo(name, relativePath))
                            }
                        }
                    }
                    // Sound effects
                    file.extension.lowercase() in listOf("wav", "raw") -> {
                        sounds.add(AssetInfo(name, relativePath))
                    }
                    // Music
                    file.extension.lowercase() in listOf("mod", "s3m", "gbs") -> {
                        music.add(AssetInfo(name, relativePath))
                    }
                }
            }

        logger.lifecycle(
            "Found ${sprites.size} sprites, ${tiles.size} tiles, ${sounds.size} sounds, ${music.size} music, ${fonts.size} fonts"
        )

        // Generate the Kotlin code
        val code = generateAssetsKotlin(pkg, objName, sprites, tiles, sounds, music, fonts)

        outputKotlin.parentFile.mkdirs()
        outputKotlin.writeText(code)

        logger.lifecycle("Generated: ${outputKotlin.absolutePath}")
    }

    private fun generateEmptyAssets(packageName: String, objectName: String): String = buildString {
        appendLine("// Generated by gbkt-gradle-plugin - do not edit")
        appendLine("package $packageName")
        appendLine()
        appendLine("import io.github.gbkt.core.assets.AssetRegistry")
        appendLine()
        appendLine("object $objectName : AssetRegistry")
    }

    private fun generateAssetsKotlin(
        packageName: String,
        objectName: String,
        sprites: List<AssetInfo>,
        tiles: List<AssetInfo>,
        sounds: List<AssetInfo>,
        music: List<AssetInfo>,
        fonts: List<AssetInfo>
    ): String = buildString {
        appendLine("// Generated by gbkt-gradle-plugin - do not edit")
        appendLine("package $packageName")
        appendLine()
        appendLine("import io.github.gbkt.core.assets.AssetRegistry")
        appendLine("import io.github.gbkt.core.assets.FontAsset")
        appendLine("import io.github.gbkt.core.assets.MusicAsset")
        appendLine("import io.github.gbkt.core.assets.SoundAsset")
        appendLine("import io.github.gbkt.core.assets.SpriteAsset")
        appendLine("import io.github.gbkt.core.assets.TileAsset")
        appendLine()
        appendLine("object $objectName : AssetRegistry {")

        // Generate nested objects for each asset type
        if (sprites.isNotEmpty()) {
            appendLine("    object Sprites {")
            sprites.forEach { asset ->
                appendLine("        val ${asset.name} = SpriteAsset(\"${asset.path}\")")
            }
            appendLine("    }")
            appendLine()
        }

        if (tiles.isNotEmpty()) {
            appendLine("    object Tiles {")
            tiles.forEach { asset ->
                appendLine("        val ${asset.name} = TileAsset(\"${asset.path}\")")
            }
            appendLine("    }")
            appendLine()
        }

        if (sounds.isNotEmpty()) {
            appendLine("    object Sounds {")
            sounds.forEach { asset ->
                appendLine("        val ${asset.name} = SoundAsset(\"${asset.path}\")")
            }
            appendLine("    }")
            appendLine()
        }

        if (music.isNotEmpty()) {
            appendLine("    object Music {")
            music.forEach { asset ->
                appendLine("        val ${asset.name} = MusicAsset(\"${asset.path}\")")
            }
            appendLine("    }")
            appendLine()
        }

        if (fonts.isNotEmpty()) {
            appendLine("    object Fonts {")
            fonts.forEach { asset ->
                appendLine("        val ${asset.name} = FontAsset(\"${asset.path}\")")
            }
            appendLine("    }")
            appendLine()
        }

        // Generate registry overrides
        if (sprites.isNotEmpty()) {
            appendLine("    override val sprites = mapOf(")
            sprites.forEachIndexed { index, asset ->
                val comma = if (index < sprites.size - 1) "," else ""
                appendLine("        \"${asset.name}\" to Sprites.${asset.name}$comma")
            }
            appendLine("    )")
            appendLine()
        }

        if (tiles.isNotEmpty()) {
            appendLine("    override val tiles = mapOf(")
            tiles.forEachIndexed { index, asset ->
                val comma = if (index < tiles.size - 1) "," else ""
                appendLine("        \"${asset.name}\" to Tiles.${asset.name}$comma")
            }
            appendLine("    )")
            appendLine()
        }

        if (sounds.isNotEmpty()) {
            appendLine("    override val sounds = mapOf(")
            sounds.forEachIndexed { index, asset ->
                val comma = if (index < sounds.size - 1) "," else ""
                appendLine("        \"${asset.name}\" to Sounds.${asset.name}$comma")
            }
            appendLine("    )")
            appendLine()
        }

        if (music.isNotEmpty()) {
            appendLine("    override val music = mapOf(")
            music.forEachIndexed { index, asset ->
                val comma = if (index < music.size - 1) "," else ""
                appendLine("        \"${asset.name}\" to Music.${asset.name}$comma")
            }
            appendLine("    )")
            appendLine()
        }

        if (fonts.isNotEmpty()) {
            appendLine("    override val fonts = mapOf(")
            fonts.forEachIndexed { index, asset ->
                val comma = if (index < fonts.size - 1) "," else ""
                appendLine("        \"${asset.name}\" to Fonts.${asset.name}$comma")
            }
            appendLine("    )")
        }

        appendLine("}")
    }

    /**
     * Convert a filename to a valid Kotlin identifier.
     * - Replace hyphens and spaces with underscores
     * - Ensure it starts with a letter or underscore
     * - Convert to camelCase
     */
    private fun String.toKotlinIdentifier(): String {
        val sanitized = this.replace("-", "_").replace(" ", "_").replace(".", "_")

        // If starts with a digit, prefix with underscore
        val prefixed = if (sanitized.firstOrNull()?.isDigit() == true) "_$sanitized" else sanitized

        // Convert to camelCase
        return prefixed
            .split("_")
            .filter { it.isNotEmpty() }
            .mapIndexed { index, part ->
                if (index == 0) part.lowercase() else part.replaceFirstChar { it.uppercase() }
            }
            .joinToString("")
    }

    private data class AssetInfo(val name: String, val path: String)
}
